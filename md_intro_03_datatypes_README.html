<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Variables, Data Types, Expressions, Assignment, Formatting | Awesome
Cpp
Course</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-76LZTVL113"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-76LZTVL113');
  </script>
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Awesome
Cpp
Course</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li>
              <a href="/">Courses</a>
              <ol>
                <li><a href="md_intro_README.html">Intro to Programming</a></li>
                <li><a href="md_portfolio_README.html">Portfolio</a></li>
                <li><a href="md_artificialintelligence_README.html">Artificial Intelligence</a></li>
              </ol>
            </li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="2">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Variables, Data Types, Expressions, Assignment, Formatting
        </h1>
<section id="autotoc_md35"><h2><a href="#autotoc_md35">Variables</a></h2><p>Variables are containers to store information and facilitates data manipulation. They are named and typed. <a href="https://en.cppreference.com/book/intro/variables">Detailed Reference</a></p><p>Container sizes are measured in Bytes. Bytes are the smallest addressable unit in a computer. Each byte is composed by 8 bits. Each bit can be <code>1</code> or <code>0</code> (<code>true</code> or <code>false</code>). If one byte have 8 bits and each bit one can hold 2 different values, the combination of all possible cases that a byte can be is <code>2^8</code> which is <code>256</code>, so one byte can hold up to <code>256</code> different states or possibilities.</p><section id="autotoc_md36"><h3><a href="#autotoc_md36">Data Types</a></h3><p>There are several types of variables in C++, including:</p><ul><li>Primitive data types: These are the most basic data types in C++ and include integer, floating-point, character, and boolean types.</li><li>Derived data types: These data types are derived from the primitive data types and include arrays, pointers, and references.</li><li>User-defined data types: These data types are defined by the programmer and include structures, classes, and enumerations.</li></ul><p><a href="https://en.cppreference.com/w/cpp/language/types">Detailed Reference</a></p><section id="autotoc_md37"><h4><a href="#autotoc_md37">Numeric types</a></h4><p>There are some basic integer container types with different sizes. It can have some type modifiers to change the default behavior or the type.</p><p>The common size of the integer containers are <code>1</code>(<code>char</code>), <code>2</code>(<code>short int</code>), <code>4</code>(<code>int</code>) or <code>8</code>(<code>long long</code>) bytes. <a href="https://en.cppreference.com/w/cpp/language/types">For a more detailed coverage read this</a>.</p><p>NOTE1: But the only guarantee the C++ imposes is: <code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code> and it can result in compiler defined behaviours where a <code>char</code> can have 8 bytes and a <code>long long</code> can be 1 byte.</p><p>NOTE2: If you care about being cross-platform conformant, you have to always specify the sign modifier or use a more descriptive type such as listed <a href="https://en.cppreference.com/w/cpp/header/cstdint">here</a>.</p><p>For floating pointing numbers, the container size can be <code>4</code>(<code>float</code>), <code>8</code>(<code>double</code>), <code>10</code>(deprecated) or <code>16</code>(<code>long double</code>) bytes.</p><p>The sign modifiers can be <code>signed</code> and <code>unsigned</code> and are applicable only for integer types.</p><p>The default behavior of the types in a x86 cpu are as signed numbers and the first bit of the container is the signal. If the first bit is <code>0</code>, it means it is positive. If the first bit is <code>1</code>, it means it is negative. <a href="https://en.wikipedia.org/wiki/Two%27s_complement">More details</a>.</p><p>Which means that if the container is the size of 1 byte(8 bits), it have 1 bit for the signal and 7 bit for the content. So this number goes from <code>-128</code> up to <code>127</code>, this container is typically a <code>char</code>. The positive size has 1 less quantity in absolute than the negative because 0 is represented in positive side. There are <code>256</code> numbers between <code>-128</code> and <code>127</code> inclusive.<br /></p><section id="autotoc_md38"><h5><a href="#autotoc_md38">Char</a></h5><p>A standard <code>char</code> type uses 1 byte to store data.</p><p>It can represent <code>2^8</code> or <code>256</code> different numbers. By default, in x86 machine char is signed and the represented numbers can go from <code>-2^7</code> or <code>-128</code> up to <code>2^7 - 1</code> or <code>127</code>.</p><p>Chars can be used to represent letters following the <a href="https://www.asciitable.com/">ascii table</a> where each value means a specific letter, digit or symbol.</p><p>NOTE: A <code>char</code> can have different sizes to represent different character coding for different languages. If you are using hebrew, chinese, or others, you probably will need more than 1 byte to represent the chars. Use <code>char8_t</code> (UTF8), <code>char16_t</code>(UTF16) or <code>char36_t</code>(UTF32), to cover your character encoding for the language you are using.</p></section><section id="autotoc_md39"><h5><a href="#autotoc_md39">Integer</a></h5><p>NOTE: Most of the information that I am covering here might be not precise, but the overall idea is correct. If you want a deep dive, <a href="https://en.cppreference.com/w/cpp/language/types">read this</a>.</p><p>A standard <code>int</code> type uses 4 bytes to store data. It is signed by default.</p><p>It can represent <code>2^32</code> or <code>4294967296</code> different numbers. As a signed type, it can represent numbers from <code>-2^31</code> or <code>-2147483648</code> up to <code>2^31 - 1</code> or <code>2147483647</code>.</p><p>The type <code>int</code> can accept sign modifiers as <code>signed</code> or <code>unsigned</code> to change the behavior of the first bit to act as a sign or not.</p><p>The type <code>int</code> can accept size modifiers as <code>short</code> (2 bytes) or <code>long long</code> (8 bytes) to change the size and representation capacity of the container. Type declaration <code>short</code> and <code>short int</code> result in the same container size of 2 bytes. In the same way a <code>long long</code> or <code>long long int</code> reserves the same size of 8 bytes for the container.</p><p>The type <code>long</code> or <code>long int</code> usually gives the same size of <code>int</code> as 4 bytes. Historical fact or myth: This abnormality, comes from the evolution of the definition of <code>int</code>: in the past, 2 bytes were enough for the majority of the scenarios in the 16 bits processors, but it frequently reached the limits of the container and it overflowed. So they changed the standard definition of a integer from being 2 bytes to 4 bytes, and created the short modifier. In this scenario the long int lost the reason to exist.</p><p>Here goes a list of valid integer types and its probable size(it depends on the implementation, cpu architecture and operation system):</p><ul><li>Size of 2 bytes: <code>short int</code>, <code>short</code>, <code>signed short int</code>, <code>signed short</code>, <code>unsigned short int</code>, <code>unsigned short</code>,</li><li>Size of 4 bytes: <code>signed</code>, <code>unsigned</code>, <code>int</code>, <code>signed int</code>, <code>unsigned int</code>, <code>long int</code>, <code>long</code>, <code>signed long int</code>, <code>signed long</code>, <code>unsigned long int</code>, <code>unsigned long</code>,</li><li>Size of 8 bytes: <code>long long int</code>, <code>long long</code>, <code>signed long long int</code>, <code>signed long long</code>, <code>unsigned long long int</code>, <code>unsigned long long</code>.</li></ul><p>OPINION: I highly recommend the usage of <a href="https://en.cppreference.com/w/cpp/header/cstdint">these types instead</a>, to ensure determinism and consistency between compilers, operating systems and cpu architectures.</p></section><section id="autotoc_md40"><h5><a href="#autotoc_md40">Float pointing</a></h5><p>There are 3 basic types of floating point containers: <code>float</code>(4 bytes) and <code>double</code>(8 bytes) and <code>long double</code>(16 bytes) to represent fractional numeric types.</p><p>The <a href="https://en.wikipedia.org/wiki/IEEE_754">standard IEEE754</a> specifies how a floating point number is stored in the form of bits inside the container. The container holds 3 basic information to simulate the behavior of a fractional type inside a binary type: signal, exponent and fraction.</p><p>NOTE: This standard was very open to implementation definition in the past, and this is one of the root causes of non-determinism physics simulation. This is the main problem you cannot guarantee the same operation with the same pair of numbers will consistently give the same result across different types of processors and compilers, thus making the physics of a multiplayer game consistency hardly achievable. Many deterministic physics engines tend to not use this standard at all, and implement those behaviors via software on top of integers instead. There are 2 approaches to solve the floating-point determinism: <a href="https://github.com/ucb-bar/berkeley-softfloat-3">softfloat</a> that implement all the IEEE754 specifications via software, or implement some kind of <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed-point arithmetic</a> on top of integers.</p></section><section id="autotoc_md41"><h5><a href="#autotoc_md41">Booleans</a></h5><p><code>bool</code> is a special type that has the container size of 1 byte but the compiler can optimize and pack up to 8 <code>bool</code>s in one byte if they are declared in sequence.</p></section></section><section id="autotoc_md42"><h4><a href="#autotoc_md42">Special derived type: string</a></h4><p><code>string</code> is a derived type and in order to use it, string should be included in the beginning of the file or in the header. <code>char</code> are the basic unit of a <code>string</code> and is used to store words as a sequence of chars.</p><p>In C++, a string is a sequence of characters that is stored in an object of the <code>std::string</code> class. The <code>std::string</code> class is part of the C++ Standard Library and provides a variety of functions and operators for manipulating strings.</p></section></section><section id="autotoc_md43"><h3><a href="#autotoc_md43">Variable Naming</a></h3><p>Variable names are called identifiers. In C++, you can use any combination of letters, digits, and underscores to name a variable, it should follow some rules:</p><ul><li>Variables can have numbers, en any position, except the first character, so the name does not begin with a digit. Ex. <code>point2</code> and <code>vector2d</code> are allowed, but <code>9life</code> isn&#x27;t;</li><li>Variable names are case-sensitive, so &quot;myVar&quot; and &quot;myvar&quot; are considered to be different variables;</li><li>Can have <code>_</code> in any position of the identifier. Ex. <code>_myname</code> and <code>user_name</code> are allowed;</li><li>It is not a <a href="https://en.cppreference.com/w/cpp/keyword">reserved keyword</a>;</li></ul><p>Keep in mind that it is a good practice to choose descriptive and meaningful names for your variables, as this can make your code easier to read and understand. Avoid using abbreviations or acronyms that may not be familiar to others who may read your code.</p><p>It is also important to note that C++ has some naming conventions that are commonly followed by programmers. For example, it is common to use camelCase or snake_case to separate words in a variable name, and to use all lowercase letters for variables that are local to a function and all uppercase letters for constants.</p></section><section id="autotoc_md44"><h3><a href="#autotoc_md44">Variable declaration</a></h3><p>Variable declaration in C++ follows this pattern.</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="n">TYPENAME</span><span class="w"> </span><span class="n">VARIABLENAME</span><span class="p">;</span><span class="w"></span></pre> <p><code>TYPENAME</code> can be the name of any predefined type. See <a href="#variable-types">Variable Types</a> for the types. <code>VARIABLENAME</code> can be anything as long it follow the naming rules. See <a href="#variable-naming">Variable Naming</a> for the naming rules.</p><p>NOTE: A given variable name can only be declared once in the same context / scope. If you try to redeclare the same variable, the compiler will accuse an error. NOTE2: You can redeclare the same variable name in different scopes. If one scope is parent of the other, the current will be used and will shadow the content of the one from outer scope. We are going to cover this more when we are covering multi-file projects and functions.</p><p>Examples:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">       </span><span class="c1">// integer variable</span>
<span class="kt">float</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span><span class="w">    </span><span class="c1">// floating-point variable</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">      </span><span class="c1">// character variable</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">      </span><span class="c1">// boolean variable</span>
<span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">// string variable </span></pre><p>NOTE: We are going to cover later in this course other complex types in other modules such as arrays, pointers and references.</p></section></section><section id="autotoc_md45"><h2><a href="#autotoc_md45">Variable assignment</a></h2><p><code>=</code> operator means that whatever the container have will be overwritten by the result of the right side statement. You should read it not as <code>equal</code> but as <code>receives</code> to avoid misunderstanding. <a href="https://en.cppreference.com/w/cpp/language/operator_assignment">Reference</a></p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">         </span><span class="c1">// integer variable</span>
<span class="kt">float</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w">    </span><span class="c1">// floating-point variable</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w">       </span><span class="c1">// character variable</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">      </span><span class="c1">// boolean variable</span>
<span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;John Doe&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// string variable </span></pre><p>Every variable, by default, is not initialized. It means that you have to set the content of it after declaring. If the variable is read before the assignment, its content is garbage, it will read whatever is set in the memory stack for the given container location. So the best approach is to always set a value when a variable is declared or be assured that every variable is never read before an assigment.</p><p>A <code>char</code> variable can be assigned by integer numbers or any characters between single quotes.</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// the content is 65 and the representation is A. see ascii table.</span>
<span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">98</span><span class="p">;</span><span class="w"> </span><span class="c1">// the content is 98 and the representation is b. see ascii table.</span></pre><p>A <code>bool</code> is by default either <code>true</code> or <code>false</code>, but it can be assigned by numeric value following this rule:</p><ul><li>if the value is <code>0</code>, then the value stored by the variable is <code>false</code> (<code>0</code>);</li><li>if the value is anything different than <code>0</code>, the value stored is <code>true</code> (<code>1</code>);</li></ul><p>To convert a <code>string</code> to a <code>int</code>, you have to use a function <a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">stoi</a>(for <code>int</code>), <a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">stol</a>(for <code>long</code>) or <a href="https://en.cppreference.com/w/cpp/string/basic_string/stol">stoll</a>(for <code>long long</code>) because both types are not compatibles.</p><p>To convert a <code>string</code> to a <code>float</code>, you have to use a function <a href="https://en.cppreference.com/w/cpp/string/basic_string/stof">stof</a>(for <code>float</code>), <a href="https://en.cppreference.com/w/cpp/string/basic_string/stof">stod</a>(for <code>double</code>), or <a href="https://en.cppreference.com/w/cpp/string/basic_string/stof">stold</a>(for <code>long double</code>) because both types are not compatibles.</p></section><section id="autotoc_md46"><h2><a href="#autotoc_md46">Literals</a></h2><p>Literals are values that are expressed freely in the code. Every numeric type can be appended with suffixes to specify explicitly the type to avoid undefined behaviors or compiler defined behaviors such as implicit cast or container size.</p><section id="autotoc_md47"><h3><a href="#autotoc_md47">Integer literals</a></h3><p>There are 4 types of integer literals.</p><ul><li>decimal-literal: never starts with digit <code>0</code> and followed by any decimal digit;</li><li>octal-literal: starts with <code>0</code> digit and followed by any octal digit;</li><li>hex-literal: starts with <code>0x</code> or <code>0X</code> and followed by any hexadecimal digit;</li><li>binary-literal: starts with <code>0b</code> or <code>0B</code> and followed by any binary digit;</li></ul><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="c1">// all of these variables holds the same value, 42, but using different bases.</span>
<span class="c1">// the right side of the = are literals</span>
<span class="kt">int</span><span class="w"> </span><span class="n">deci</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="n">octa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">052</span><span class="p">;</span><span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="n">hexa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x2a</span><span class="p">;</span><span class="w"> </span>
<span class="kt">int</span><span class="w"> </span><span class="n">bina</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b101010</span><span class="p">;</span><span class="w"></span></pre><p>Suffixes:</p><ul><li><code>no suffix</code> provided: it will use the first smallest signed integer container that can hold the data starting from <code>int</code>;</li><li><code>u</code> or <code>U</code>: it will use the first smallest unsigned integer container that can hold the data starting from <code>unsigned int</code>;</li><li><code>l</code> or <code>L</code>: it will use the first smallest signed integer container that can hold the data starting from <code>long</code>;</li><li><code>lu</code> or <code>LU</code>: it will use the first smallest unsigned integer container that can hold the data starting from <code>unsigned long</code>;</li><li><code>ll</code> or <code>LL</code>: it will use the long long signed integer container <code>long long</code>;</li><li><code>llu</code> or <code>LLU</code>: it will use the long long unsigned integer container <code>unsigned long long</code>;</li></ul><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15731685574866854135ull</span><span class="p">;</span><span class="w"></span></pre><p><a href="https://en.cppreference.com/w/cpp/language/integer_literal">Reference</a></p></section><section id="autotoc_md48"><h3><a href="#autotoc_md48">Float point literals</a></h3><p>There are 3 suffixes in floating point decimals.</p><ul><li><code>no suffix</code> means the container is a double;</li><li><code>f</code> suffix means it is a float container;</li><li><code>l</code> suffix means it is a long double container;</li></ul><p>A floating point literal can be defined by 3 ways:</p><ul><li>digit-sequence decimal-exponent suffix(optional).<ul><li><code>1e2</code> means its a <code>double</code> with the value of <code>1*10^2</code> or <code>100</code>;</li><li><code>1e-2f</code> means its a <code>float</code> with the value of <code>1*10^-2</code> or <code>0.01</code>;</li></ul></li><li>digit-sequence . decimal-exponent(optional) suffix(optional).<br /><ul><li><code>2.</code> means it is a <code>double</code> with value of <code>2</code>;</li><li><code>2.f</code> means it is a <code>float</code> with value of <code>2</code>;</li><li><code>2.1l</code> means it is a <code>long double</code> with value of <code>2.1</code>;</li></ul></li><li>digit-sequence(optional) . digit-sequence decimal-exponent(optional) suffix(optional)<ul><li><code>3.1415f</code> means it is a <code>float</code> with value of <code>3.1415</code>;</li><li><code>.1</code> means it is a <code>double</code> with value of <code>0.1</code>;</li><li><code>0.1e1L</code> means it is a <code>long double</code> with value of <code>1</code>;</li></ul></li></ul><p><a href="https://en.cppreference.com/w/cpp/language/floating_literal">Reference</a></p></section></section><section id="autotoc_md49"><h2><a href="#autotoc_md49">Arithmetic Operations</a></h2><p>In C++, you can perform common arithmetic operations is statements using the following operators <a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic">Reference</a>:</p><ul><li>Addition: <code>+</code></li><li>Subtraction: <code>-</code></li><li>Multiplication: <code>*</code></li><li>Division: <code>/</code></li><li>Modulus (remainder): <code>%</code></li></ul><p>There are two special cases called unary increment / decrement operators that may occur in before(prefixed) or after(postfixed) the variable name <a href="https://en.cppreference.com/w/cpp/language/operator_incdec">reference</a>. If prefixed it is executed first and then return the result, if postfixed, it returns the current value and then execute the operation:</p><ul><li>Increment: <code>++</code>;</li><li>Decrement: <code>--</code>;</li></ul><p>There are compound assignment operators <a href="https://en.cppreference.com/w/cpp/language/operator_assignment">reference</a> that reassign the value of the variable after executing the arithmetic operation with the right side of the operator with the old value of the variable:</p><ul><li>Addition: <code>+=</code></li><li>Subtraction: <code>-=</code></li><li>Multiplication: <code>*=</code></li><li>Division: <code>/=</code></li><li>Modulus (remainder): <code>%=</code></li></ul><p>Here is an example of how to use these operators in a C++ program:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 7</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 3</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 10</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 2</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 1</span>
<span class="w">  </span><span class="n">a</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 6</span>
<span class="w">  </span><span class="n">a</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 5</span>
<span class="w">  </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">++</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 5 because it first returns the current value and then increments.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 6</span>
<span class="w">  </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">--</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 5 because it first decrements the value and then return it already changed;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 5</span>
<span class="w">  </span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// it is a short version of b = b * 2; </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 4</span>
<span class="w">  </span>
<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// it is a short version of b = b / 2; </span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Outputs 2</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Note that the division operator (<code>/</code>) performs integer division if both operands are integers. If either operand is a floating-point type, the division will be performed as floating-point division. So <code>5/2</code> is <code>2</code> because both are integers, se we use integer division, but <code>5/2.</code> is <code>2.5</code> because the second one is a <code>double</code> literal.</p><p>Also, the modulus operator (<code>%</code>) returns the remainder of an integer division. For example, <code>7 % 3</code> is equal to <code>1</code>, because <code>3</code> goes into <code>7</code> two times with a remainder of <code>1</code>.</p><section id="autotoc_md50"><h3><a href="#autotoc_md50">Implicit cast</a></h3><p>Implicit casting, also known as type coercion, is the process of converting a value of one data type to another data type without the need for an explicit cast operator. In C++, this can occur when an expression involves operands of different data types and the compiler automatically converts one of the operands to the data type of the other in order to perform the operation.</p><p>For example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// c is automatically converted to a double before the addition</span></pre><p>In this example, the value of <code>b</code> is a double, while the value of <code>a</code> is an <code>int</code>. When the addition operator is used, the compiler will automatically convert a to a <code>double</code> before performing the addition. The result of the expression is a <code>double</code>, so <code>c</code> is also automatically converted to a <code>double</code> before being assigned the result of the expression.</p><p>Implicit casting can also occur when assigning a value to a variable of a different data type. For example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// a is automatically converted to a double before the assignment</span></pre><p>In this case, the value of <code>a</code> is an int, but it is being assigned to a double variable. The compiler will automatically convert the value of <code>a</code> to a <code>double</code> before making the assignment.</p><p>It&#x27;s important to be aware of implicit casting, because it can sometimes lead to unexpected results or loss of precision if not handled properly. In some cases, it may be necessary to use an explicit cast operator to explicitly convert a value to a specific data type.</p></section><section id="autotoc_md51"><h3><a href="#autotoc_md51">Explicit cast</a></h3><p>In C++, you can use an explicit cast operator to explicitly convert a value of one data type to another. The general syntax for an explicit cast is:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="p">(</span><span class="n">TYPENAME</span><span class="p">)</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span></pre><p>For example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// a is explicitly converted to a double</span></pre><p>In this example, the value of <code>a</code> is an <code>int</code>, but it is being explicitly converted to a <code>double</code> using the explicit cast operator. The result of the cast is then assigned to the <code>double</code> variable <code>b</code>.</p><p>Explicit casts can be useful in situations where you want to ensure that a value is converted to a specific data type, regardless of the data types of the operands in an expression. However, it&#x27;s important to be aware that explicit casts can also lead to unexpected results or loss of precision if not used carefully.</p><p>For example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20001</span><span class="p">;</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// b is assigned the ASCII value for the character &#39;?&#39;</span></pre><p>In this case, the value of <code>a</code> is an <code>int</code>, but it is being explicitly converted to a <code>char</code> using the explicit cast operator. However, the range of values that can be represented by a <code>char</code> is much smaller than the range of values that can be represented by an <code>int</code>, so the value of <code>a</code> is outside the range that can be represented by a <code>char</code>. As a result, <code>b</code> is assigned the ASCII value for the character <code>1</code>, which is not the same as the original value of <code>a</code>. The value <code>!</code> is <code>33</code> in ASCII table, and <code>33</code> is the result of the <code>20001 % 256</code> where <code>256</code> is the number of elements the <code>char</code> can represent. In this case, what happened was a bug that is hard to track called <code>int overflow</code>.</p></section></section><section id="autotoc_md52"><h2><a href="#autotoc_md52">Formatting</a></h2><p>There are many functions to help you format the output in the way it is expected, here goes a selection of the most useful ones I can think. Yon can find more functions and manipulators <a href="https://en.cppreference.com/w/cpp/header/iomanip">here</a> and <a href="https://en.cppreference.com/w/cpp/header/ios">here</a>.</p><p>To set a fixed precision for floating point numbers in C++, you can use the <code>std::setprecision</code> manipulator from the <code>iomanip</code> header, along with the <code>std::fixed</code> manipulator.</p><p>Here&#x27;s an example of how to use these manipulators to output a floating point number with a fixed precision of 3 decimal places:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159265</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">fixed</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Output: 3.142</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>You can also use the <code>std::setw</code> manipulator to set the minimum field width for the output, which can be useful for aligning the decimal points in a table of numbers.</p><p>For example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159265</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">num2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">123.456789</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">fixed</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">fixed</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Output:</span>
<span class="w">  </span><span class="c1">//   3.142</span>
<span class="w">  </span><span class="c1">// 123.457</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Note that these manipulators only affect the output stream, and do not modify the values of the floating point variables themselves. If you want to store the numbers with a fixed precision, you will need to use a different method such as rounding or truncating the numbers.</p><p>To align text to the right or left in C++, you can use the <code>setw</code> manipulator in the <code>iomanip</code> header and the <code>right</code> or <code>left</code> flag. <a href="https://en.cppreference.com/w/cpp/io/manip/left">More details here</a></p><p>Here is an example:</p><pre class="m-code"><span class="w"> </span><span class="p">{</span><span class="n">c</span><span class="o">++</span><span class="p">}</span><span class="w"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">right</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Apple&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Banana&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Both will print inside a virtual column with the size of 10 chars. This will output the following:</p><pre class="m-code">    Apple
Banana</pre></section><section id="autotoc_md53"><h2><a href="#autotoc_md53">Optional Exercises</a></h2><p>In order to get into coding, the easiest way to learn is by solving coding challenges. It is like learning any new language, you have to be exposed and involved. Do not do only the homeworks, otherwise you are going to fail. Another metaphor is: the homework is the like a competition that you have to run to prove that you are trained, but in order to train, you have to do small runs and do small steps first, so you have to train yourself ot least 2x per week.</p><p>The best way to train yourself in coding and solving problems in my opinion is this:</p><ol><li>Sort Beecrowd questions from the most solved to the least solved questions <a href="https://www.beecrowd.com.br/judge/en/search?q=&amp;sort=Problems.solved&amp;direction=desc">here</a> is the link of the list already filtered.</li><li>Start solving the questions from the top to the bottom. Chose one from de the beginning, it would be one of the easiest;</li><li>If you are feeling comfortable and being able to solve more than 3 per hour, you are allowed to skip some of the questions. It is just like in a gym, when you get used with the load, you increase it. Otherwise continue training slowly.</li></ol></section><section id="autotoc_md54"><h2><a href="#autotoc_md54">Homework</a></h2><ul><li><a href="https://www.beecrowd.com.br/judge/en/problems/view/1021">banknotes and coins</a> - Here you will use formatting, modulus, casting, arithmetic operations, compound assignment.</li></ul></section><section id="autotoc_md55"><h2><a href="#autotoc_md55">Troubleshooting</a></h2><p>If you have problems here, start a <a href="https://github.com/InfiniBrains/Introduction-to-Game-Programming-With-CPP/discussions">discussion</a> this is publicly visible and not FERPA compliant. Use discussions in Canvas if you are enrolled in a class with me.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        Awesome Cpp Course. Created by <a href="https://linktree.com/tolstenko">Alexandre Tolstenko</a> and <a href="https://github.com/InfiniBrains/Introduction-to-Game-Programming-With-CPP/graphs/contributors">Others</a>. 2023. All rights reserved.
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
